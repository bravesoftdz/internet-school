<HTML>
<HEAD>
        <TITLE> Журнал ЦПО. Дистанционное обучение. </TITLE>
        <META NAME="Author" CONTENT="Olga Pavlova (OP), CHANCE Publishing House">
</HEAD>

<BODY BGCOLOR="#EFEFEF" TEXT="Black" LINK="Teal" VLINK="Gray" ALINK="#B3CFC4">


<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
<TR>
        <TD width=2% ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
        <TD width=2% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
        <TD ALIGN="CENTER" BGCOLOR="Gray">
        <FONT COLOR="White">
        <EM>Компьютерные</EM><BR>
        <FONT SIZE="+1"><STRONG>ИНСТРУМЕНТЫ</STRONG></FONT><BR>
        <EM>в образовании</EM>
        </FONT>
        </TD>
        <TD width=2% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
        <TD width=2% ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
</TR>

<TR>
        <TD BGCOLOR="Black">&nbsp;</TD>
</TR>

<TR>
<TD COLSPAN="5" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1">
<HR SIZE="1" NOSHADE>
[ <A HREF="index.html">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE>
</FONT>
</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" ALIGN="CENTER" VALIGN="MIDDLE" NOWRAP BGCOLOR="#82B496">
<TR>
<TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>&nbsp;СЦЕНАРИИ&nbsp;<BR>
&nbsp;УРОКОВ&nbsp;</EM></FONT></TD>

<TD WIDTH="70%" BGCOLOR="#EFEFEF">
<P ALIGN="RIGHT"><FONT SIZE="-1"><EM>Дмитриева Марина Валерьевна&nbsp;&nbsp;&nbsp;<BR>
Павлова Марианна Владимировна&nbsp;&nbsp;&nbsp;</EM></FONT></P>

<H3 ALIGN="CENTER">Элементы теории множеств. Система: ее структура и состояние.
</H3>
&nbsp;
</TD>
</TR>

<TR>
<TD COLSPAN="2">&nbsp;</TD>
</TR>
</TABLE>


<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD WIDTH="97%" BGCOLOR="#EFEFEF">&nbsp;</TD>

<TD WIDTH="3%">&nbsp;</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Множества и операции над ними.&nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="3%">&nbsp;</TD>

<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<P>&nbsp;&nbsp;&nbsp;<STRONG>М</STRONG>ножеством называют определенную совокупность объектов. Один из создателей теории множеств Георг Кантор(1845-1918) сказал : ¦Множество есть многое, мыслимое нами как единое¦. Строгого определения множества нет, так как это понятие, из которого выводятся многие понятия математики, тогда как оно не выводится из других понятий и не определяется. Понятие множества столь же первично как понятие точки или числа. Синонимами слова ¦множество¦ можно считать такие слова как ¦совокупность¦, ¦коллекция¦, ¦семейство¦, ¦собрание¦. В дальнейшем понятие множества будет разъяснено на примерах. 
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> Объекты, из которых составлено множество, называются элементами данного множества.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>ет никаких ограничений на природу элементов, составляющих множество. Например: различные предметы меблировки комнаты образуют множество. Множествами являются книги некоторой библиотеки, учащиеся класса, буквы алфавита, автомобили на дорогах города, целые числа от 1 до 1000, атомы серебра в данной монете или всевозможные идеи, которые имело человечество.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> множество, имеющее конечное число элементов, называется конечным. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>В</STRONG>се рассмотренные ранее примеры служат примерами конечных множеств.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> множество называется бесконечным, если оно состоит из бесконечного числа элементов.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, множество всех вещественных чисел бесконечно.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> множество, в котором нет ни одного элемента, называют пустым множеством.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, множество летающих бегемотов пусто.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля обозначения множества используют заглавные буквы латинского алфавита, а в фигурных скобках через запятую выписывают его элементы. Пустое множество записывают как {} или Ж. Если некоторый элемент принадлежит множеству, то это обозначают знаком ¦О¦, а если не принадлежит, то знаком  ¦П¦.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример: A={3,5,6}; M={L,¬,¬,(c)}; L={}; 5ОA; ¬ОM; 2ПA; ¬ПL.
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>уществует два способа задания конечных множеств. Можно либо дать полный перечень элементов этого множества, либо указать правило для определения того, принадлежит или нет рассматриваемому множеству данный объект. Первый способ называется перечислением множества, а второй - описанием. Для бесконечных множеств возможен лишь второй способ.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, перечисление {2,4,6,8} или описание ¦Четные числа, большие 0 и меньшие 10¦; перечисление {вторник, среда, четверг} или описание ¦Первый, второй и третий дни после понедельника¦.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> множество, состоящее из некоторых элементов другого множества, называется его подмножеством. Утверждение, что множество A  является подмножеством  множества B, записывают так: AНB. Считается, что пустое множество является подмножеством любого множества. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, множества {4,8} и {6} являются подмножествами множества {2,4,6,8}; числа 2, 4, 6, 8 - его элементы. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>М</STRONG>ножество { {},{2},{4},{6},{8},{2,4},{2,6},{2,8},{4,6},{4,8},{6,8},{2,4,6},{2,4,8},{2,6,8},{4,6,8},{2,4,6,8} } является множеством всех подмножеств исходного множества. Из последнего примера видно, что множества сами могут быть элементами  какого-то множества. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>У</STRONG> любого множества есть обязательно хотя бы два подмножества: пустое множество и само множество. Эти два подмножества называются несобственными подмножествами. Любое подмножество, отличное от несобственного, называется собственным подмножеством данного множества.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>етрудно видеть, что у пустого множества нет собственных подмножеств, а оба несобственных подмножества равны между собой. У любого одноэлементного множества также нет собственных подмножеств, но его несобственные подмножества различны. У любого двухэлементного  множества есть уже два собственных подмножества. С ростом количества элементов в множестве количество собственных подмножеств растет.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, если F={s, t}, то собственными подмножествами множества F будут являться множества {s} и {t}.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> множества, состоящие из одних и тех же элементов, называются равными. При этом порядок перечисления элементов множества значения не имеет.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример: равны множество равносторонних треугольников и множество равноугольных треугольников; равны множества {7,4,1}, {1,4,7} и {7,1,4}.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> мощностью конечного множества (размером конечного множества) называют количество его элементов. Мощность пустого множества равна нулю.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример: мощность множества углов любой трапеции равна четырем, а мощность множества четных чисел, принадлежащих отрезку [1, 10] равна 5.
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>уществуют несколько основных операций над множествами. С их помощью можно строить новые множества.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> объединением множеств А и В называется множество, содержащее все элементы из А и все элементы из В. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>О</STRONG>бъединением любого множества с пустым является само это множество.
<P>&nbsp;&nbsp;&nbsp;<STRONG>О</STRONG>бъединение множеств обозначается знаком ¦И¦.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, пусть A={5,7,9}, B={6,1}. Тогда C=AИB={1,5,6,7,9}.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> пересечением множеств А и В называется множество, состоящее из тех элементов, которые принадлежат обоим множествам. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Е</STRONG>сли в пересечении множеств элементов нет, то говорят, что они не пересекаются или что их пересечение - пустое множество. Пересечение любого множества с пустым является пустым множеством. Пересечение множеств обозначается знаком ¦З¦.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, пусть A={4,5,7,9,10}, B={3,7,9}. Тогда C=AЗB={7,9}.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> разностью множеств А и В называется множество тех элементов из А, которые не принадлежат множеству В.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Е</STRONG>сли из любого множества  A  вычесть пустое множество, то результатом вычитания будет само множество A. Разность множеств обозначается знаком ¦\¦.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, пусть A={1,3,5,6,7}, B={6}. Тогда C=A \ B={1,3,5,7}.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Е</STRONG>сли G={гусь, кот, пTс, утка, курица, индюк}, H={кот, пTс}, то R=G\H={гусь, утка, курица, индюк}, а T=H\ Ж=H.

</BLOCKQUOTE>
<P>&nbsp;
</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Отношения и их свойства.&nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<P>&nbsp;&nbsp;&nbsp;<STRONG>М</STRONG>ы рассмотрели множества, состоящие из каких-то элементов, но ничего не говорили о свойствах этих элементов и их отношениях друг с другом. Рассмотрим теперь некоторое конечное множество элементов: A= , которое будем называть предметной областью.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> функция называется логической, если область еT значений состоит из двух логических констант истина и ложь, или другими словами, если все еT значения принадлежат множеству {истина, ложь}.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> предикатом называется логическая функция, определенная на предметной области.
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>редикаты делятся на два вида: понятия и отношения.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> понятие - свойство одного объекта  предметной области. Например, если предметная область - некоторый отрезок натурального ряда, то предикат четности - это свойство какого-то элемента (числа) из этого отрезка: быть или не быть четным. Понятия называются одноместными предикатами.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> отношение - свойство пар, троек, четверок и т.д. объектов данной предметной области.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, свойство одного элемента лежать между двумя другими является отношением (трехместным предикатом). 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апомним, что все элементы, про которые мы выясняем, находятся ли они в данном отношении, должны принадлежать рассматриваемой предметной области. Чаще всего рассматривают двуместные отношения и используют следующие обозначения: < - меньше, ё - меньше или равно, = - равно, > - больше, Ё - больше или равно, ¦ - не равно.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Е</STRONG>сли в качестве предметной области рассмотреть A - отрезок натурального ряда от 3 до 100, то отношение x < y, где x, y ОA, имеет значение истина, например, при x=6, y=123. Отношение x = y имеет значение ложь,  например, при x=50, y=49, а отношение x ¦ y имеет значение истина при тех же значениях переменных.  
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>етрудно привести примеры и других не столь известных отношений. Так отношением будет являться логическая функция, которая задана на множестве натуральных чисел, определяющая, будет ли одно натуральное число делиться на другое натуральное число без остатка. Отношением также является функция, выясняющая, какая из двух лампочек горит ярче. Кроме того, примерами отношений служат предикаты, определяющие состоят ли два человека в браке, является ли один человек родителем другого и т.п.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Р</STRONG>ассмотрим свойства двуместных отношений.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Б</STRONG>удем обозначать ¦Q¦ - знак отношения. Тогда отношение f Q g может обладать следующими свойствами: 
<UL>
<LI> отношение называется рефлексивным, если f  Q f  для любого f О A; <BR>&nbsp;
<P>&nbsp;&nbsp;&nbsp;   Например, рефлексивность имеет место для отношений  =  , &lt;=,  &gt;= , т.к. 5=5, 7ё7, 9Ё9.
<P>&nbsp;&nbsp;&nbsp;   
<LI> отношение называется транзитивным, если из того, что f Q g  и  g Q h следует,  что f Q h для любых  f, g, hОA .<BR>&nbsp;
<P>&nbsp;&nbsp;&nbsp;   Например, транзитивностью обладают отношения  =, &lt;=, &gt;=,  <, >, так как из того, что 5 < 7 и 7 < 10 следует, что 5 < 10.
<P>&nbsp;&nbsp;&nbsp;   
<LI> отношение называется симметричным, если из того, что  f Q g  следует, что  g Q f  для любых f и g ОA. <BR>&nbsp;
<P>&nbsp;&nbsp;&nbsp;   Например, пусть предметная область - отрезок целых чисел от 2 до 10000. Рассмотрим отношения: 
<OL TYPE="a">
<LI> свойство x и y иметь общий делитель, 
<LI> свойство  x и y быть равными. 
</OL>
<P>&nbsp;&nbsp;&nbsp;   Очевидно, что оба эти отношения будут симметричны.
<LI> отношение называется антисимметричным, если из того, что f  Q g  и g Q f следует, что f = g  для любых f, g ОA . <BR>&nbsp;
<P>&nbsp;&nbsp;&nbsp;   Например, антисимметричными являются отношения  ё  и  Ё, поскольку, если xёy  и yёx, то y=x для любых x,yОA. Отношение, которое определяет делится ли одно число без остатка на другое, антисимметрично, так как если x делится на y, а y делится на x, то x=y.
</UL>
<P>&nbsp;&nbsp;&nbsp;<STRONG>З</STRONG>аметим, что симметричность и антисимметричность не являются взаимоисключающими свойствами. Например, пусть множество A - множество людей. Определим отношение b так, что для любых x, y О A отношение x b y истинно тогда и только тогда, когда x брат y. В семье, где два брата p и q и сестра r, то есть на предметной области A={p, q, r} отношение b не является симметричным, так как p b r (p является братом r), но неверно, что r b p (r не является братом p). Это отношение не является и антисимметричным, так как  p b q (p брат q)  и  q b p (q брат p), хотя p и q различны.

</BLOCKQUOTE>
<P>&nbsp;
</TD>

<TD WIDTH="3%">&nbsp;</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Использование множеств при решении задач на компьютере.&nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="3%">&nbsp;</TD>

<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля того, чтобы продемонстрировать, как используются отношения, множества и операции над ними в программировании, мы выбрали язык Паскаль, так как именно на нем можно описывать и обрабатывать данные типа множество. Множество может строиться из объектов перечислимого типа или типа диапазона. Тип  множество - составной тип, и  его описание выглядит следующим образом: 
<P>&nbsp;&nbsp;&nbsp;Type множество=set  of тип-элемента, 
<P>&nbsp;&nbsp;&nbsp;где ¦множество¦- идентификатор определяемого типа, а ¦тип-элемента¦ - описатель типа элементов множества. Обычно каждая система программирования на Паскале накладывает дополнительные ограничения на возможные типы элементов. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля представления множеств в программе служит специальная конструкция, позволяющая задать набор элементов, представляющих какое-либо множество. Конструкция представляет собой набор выражений, перечисленных через запятую, заключенный в квадратные скобки. Перечисленные выражения и задают значения элементов множества, например, {'A', 'D', 'N']    {5, i+1, j-7, k, 43]  {'a', 's', 'f', 'j', 'l']     {x]   {3,8,4,2,6,1,5,7]
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>устое множество задается так: {]. Для задания в качестве элементов множества последовательности из нескольких подряд идущих значений можно указать в изображении множества первое и последнее из включаемых значений, соединив их символом ¦..¦, например: {23..67]    {2..5, 8..34]   {'0'..'9']   {'A'..'Z', 'a'..'z']   {'а'..'я']  {'Ч','Щ'..'Э','Я']
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля работы с множествами определены операции, позволяющие сравнивать множества между собой, определять принадлежность элемента множеству, выполнять обычные теоретико-множественные операции нахождения объединения, пересечения и разности множеств. Приведем таблицу допустимых операций над множествами, пояснив каждую операцию эквивалентной записью, принятой в теории множеств. В таблице М, М1 и М2 означают множества с элементами одного и того же типа, x - значение элемента множества М. Операция  принадлежности IN относится к группе операций отношения так же, как и операции отношения со знаками ¦>¦,  ¦<¦ , ¦=¦ , ¦<>¦,  ¦&lt;=¦, ¦&gt;=¦. Пользуясь этими операциями, можно выразить такие элементарные действия, как добавление в множество или удаление из него одного или нескольких элементов и другие. Например, результатом исполнения присваивания М:= М+[x] будет добавление элемента со значением x в множество М. Аналогично, в результате выполнения оператора присваивания М:=М-[x] элемент x будет удален из множества М.

<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>ользуясь аппаратом теории множеств, приведем решение нескольких задач. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 1.</STRONG> В последовательности натуральных чисел i (i&lt;256) определить число различных чисел и вывести их в порядке убывания. Признаком конца последовательности служит число 0.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Б</STRONG>удем просматривать последовательность и формировать множество чисел Z, входящих в эту последовательность. Затем выведем все элементы построенного  множества.

<PRE>
program p1;  
  type set_byte=set of byte; 
  var Z: set_byte; m:byte; k: integer;
begin writeln('Введите последовательность
                                чисел, 0 - признак конца:');
  read(m); Z:=[];     
  while m <>0 do   begin Z := Z+[m]; read(m) end;
   k:=0; writeln('Числа в порядке убывания:');
   for m:= 255 downto 1 do
      if m in Z then begin write(m,' '); inc(k) end;
              writeln;
   writeln('Количество различных чисел
                                в последовательности : ',k)
end.
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 2 .</STRONG>  Найти все простые числа, меньшие заданного N. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>М</STRONG>ожно предложить алгоритм, в котором все числа перебираются по очереди и для каждого из чисел производится проверка, является ли оно простым. Однако уже в Древней Греции был известен более эффективный алгоритм, получивший название ¦решета Эратосфена¦. Согласно этому алгоритму, сначала рассматривается множество всех чисел от 2 до N, а затем из него последовательно удаляются элементы, не являющиеся простыми числами.  Для  этого на каждом шаге алгоритма выбирается наименьший элемент множества и вычеркиваются из множества все элементы кратные выбранному. Сам элемент является простым числом и в дальнейшем не рассматривается.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Б</STRONG>удем считать, что в программе определен тип множества resheto и переменная типа множества simple , то есть выполнены описания:

<PRE>
сonst N = 255; 
type resheto = set of 2..N; 
var simple: resheto; {Формируемое множество}
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>осле выполнения оператора присваивания simple :=[2..N] переменная simple содержит множество целых значений из диапазона 2..N.  Выбираем из этого множества наименьшее простое число К.  Очевидно, что первым выбранным числом будет число 2. Далее исключаем из этого множества все числа кратные двум. Во время работы цикла в множестве simple содержатся все простые числа, не превосходящие К, а среди элементов, больших К, содержатся все числа, кроме кратных этим простым числам. Когда К пробежит значения до SQRT(N+1), в  множестве simple останутся лишь простые числа. Следующая программа реализует описанный алгоритм: 

<PRE>
program simpleres;  
  const N = 255;
  type resheto = set of 2..N;
  var simple: resheto; i,K,l: integer;
  begin writeln;   writeln ('Простые числа меньшие  ',N, ': ');
           simple :=[2..N];   L := trunc(sqrt(N+1));   K := 1;
          while K &lt;= L do
             begin repeat  K := K+1 until K in simple ;  write(K:3,' ');
                   for i :=  2 to N div K do  simple := simple - [K*i]
             end;
        for K := L+1 to N do  if K in  simple then  write(K:3,' ')
end.
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>В</STRONG> программах обработки текстов иногда удобно использовать множества символов. Тип такого множества можно описать так:

<PRE>
Type  set_sym= set of char
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>И</STRONG>спользование множеств часто оказывается эффективнее других конструкций даже в тех программах, которые впрямую не связаны с обработкой множеств, например, вместо  выражения (C &gt;='0') and (C&lt;='9') or (C &gt;='A') and (C&lt;='Z') проще и  понятнее написать C IN ['0'..'9', 'A'..'Z'], причем последняя конструкция будет, как правило, и более эффективной.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 3.</STRONG>  Определить, какие из символов заданного текста являются уникальными, то есть встречаются в тексте лишь один раз.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля решения задачи удобно использовать множества символов. При анализе текста будем формировать два множества, в множество M включим все символы, которые встречались в тексте хотя бы раз, в множество MM включим символы, которые встречались в тексте более одного раза. Первоначально оба множества пусты. После просмотра текста нужное нам множество символов получается как разность множеств M и MM. Для того, чтобы вывести результаты, необходимо перебирать все символы и для каждого символа проверять, принадлежит ли он множеству. Приведем программу, реализующую этот алгоритм:

<PRE>
program mn3;   
type set_let = set of char;   
var M1,M,MM : set_let;   s: string; c : char; i:byte;
begin
   writeln('Введите исходный текст: ');    readln(s);
   M:=[]; MM:=[];
   for i := 1 to length(s)
   do begin c:= s[i];
                 if c in M
                 then {символ уже ранее встречался}
                           MM:= MM+[c]
                 else {символ встретился впервые}
                           M:= M+[c]
       end;
   M1:= M-MM;
   Writeln ('Множество уникальных символов: ');
   if M1 = [] then writeln ('пусто')
   else
   for c := chr(0) to chr (255) do if c in M1  then
                        write(c,' ');
   Writeln;
end.
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 4.</STRONG> Написать программу, которая проверяет, состоят ли два заданных текста из одинаковых символов. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>В</STRONG> программе опишем процедуру, которая по заданной строке s формирует множество различных символов m, из которых строка состоит:

<PRE>
procedure settex (var s : string; var m : set_let);
    var i : byte;
 begin   m:=[];   for i := 1 to length (s) do
                    m := m + [s[i]]  end.
</PRE>

<P>&nbsp;&nbsp;&nbsp; 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Т</STRONG>еперь для решения задачи нам достаточно по каждому из текстов построить соответствующее множество и затем эти два множества сравнить. Полностью программа может выглядеть так:

<PRE>
Program pm4;
  type set_let = set of char;
  var m1,m2 : set_let;  s: string; c : char;
  procedure settex (var s : string; var m : set_let);
      var i : byte;
  begin   m:=[];   for i := 1 to length (s) do    m := m + [s[i]]  end;  
begin   
   writeln('Введите первый текст:'); readln(s); settex(s,m1);
   writeln('Введите второй текст:'); readln(s); settex(s,m2);  
   if m1 = m2 then writeln('Тексты состоят из одинаковых символов')
   else writeln('Тексты состоят из различных символов'); 
end.
</PRE>
        
<P>&nbsp;&nbsp;&nbsp;<STRONG>И</STRONG>спользуя множества, легко решать следующие задачи анализа текста: найти все символы, которые встречаются в двух заданных текстах; определить символы, которые встречаются в первом тексте, но не встречаются во втором; определить, сколько различных символов в тексте и т.п.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Р</STRONG>ассмотрим еще одну задачу, в которой требуется проанализировать текст. Предположим, что нас интересуют в тексте только буквы.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 5.</STRONG> В заданном тексте найти буквы, причем  отдельно сформировать буквы латинского и русского алфавитов. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>ри анализе текста сформируем множество различных символов, входящих в текст, а затем с помощью операции пересечения множеств выделим соответствующие множества. Пусть в программе переменная mlat- множество букв латинского алфавита, mrus- русского, m-множество различных символов текста. Для того, чтобы определить множество букв, встречающихся в тексте, достаточно сформировать множество m*(mrus+mlat). Приведем программу, решающую задачу:

<PRE>
program mn5; 
type set_let = set of char; 
var mlat, mrus, m, rus, lat, lit : set_let;  
     s: string; c : char;   i: word; 
procedure settex (var s : string; var m : set_let); 
 var i : byte; 
begin   m:=[];   for i := 1 to length (s) do m := m + [s[i]]  end;
begin
mlat := ['A'..'Z','a'..'z'];    mrus := ['А'..'Я','а'..'п','р'.. 'я'];
writeln;    writeln('Введите текст:');    readln(s);   settex(s,m);
writeln('Различные символы, входящие в текст:');
for c := chr(0) to chr (255)    do if c in m   then write(c);   writeln;
writeln('Буквы русского алфавита, входящие в текст:');
rus:=m*mrus;
for c := chr(0) to chr (255)  do if c in rus  then write(c); writeln;
writeln('Буквы латинского алфавита в заданном тексте:');
lat:=m*mlat;
for c := chr(0) to chr (255)  do if c in lat   then write(c); writeln;
writeln('Текст содержит буквы:');
lit:=m*(mrus+mlat);
for c := chr(0) to chr (255)  do if c in lit then write(c);
writeln;
end.
</PRE>

<P>&nbsp;&nbsp;&nbsp;<STRONG>Пример 6.</STRONG> Задан текстовый файл, содержащий русские и латинские буквы, а также, возможно, другие символы. Переписать его в другой файл, перекодировав русские буквы в латинские или сочетания латинских букв следующим образом:

</BLOCKQUOTE>
<P>&nbsp;
</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Таблица перекодировки&nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<CENTER>
<TABLE BORDER="1">
<TR><TD>а</TD><TD>б</TD><TD>в</TD><TD>г</TD><TD>д</TD><TD>е</TD><TD>ж</TD><TD>з</TD><TD>и</TD><TD>й</TD><TD>к</TD><TD>л</TD><TD>м</TD><TD>н</TD><TD>о</TD><TD>п</TD></TR>
<TR><TD>a</TD><TD>b</TD><TD>v</TD><TD>g</TD><TD>d</TD><TD>e</TD><TD>sz</TD><TD>z</TD><TD>i</TD><TD>j</TD><TD>k</TD><TD>l</TD><TD>m</TD><TD>n</TD><TD>o</TD><TD>p</TD></TR>
<TR><TD COLSPAN="16"></TD></TR>
<TR><TD>р</TD><TD>с</TD><TD>т</TD><TD>у</TD><TD>ф</TD><TD>х</TD><TD>ц</TD><TD>ч</TD><TD>ш</TD><TD>щ</TD><TD>ъ</TD><TD>ы</TD><TD>ь</TD><TD>э</TD><TD>ю</TD><TD>я</TD></TR>
<TR><TD>r</TD><TD>s</TD><TD>t</TD><TD>u</TD><TD>f</TD><TD>h</TD><TD>c</TD><TD>ch</TD><TD>sh</TD><TD>sch</TD><TD>-</TD><TD>y</TD><TD>-</TD><TD>e</TD><TD>ju</TD><TD>ja</TD></TR>
</TABLE>
</CENTER>

<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>троковая структура текстового файла, а также все символы, не являющиеся русскими буквами, должны сохраниться.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Д</STRONG>ля решения этой задачи составим таблицу перекодировки Tabcod, в которой сопоставим каждой русской букве ее латинский эквивалент. Особым образом должны обрабатываться буквы 'Ж', 'Ч', 'Ш', 'Щ', 'Ь', 'Ъ', 'Ю', 'Я', поэтому составим из этих букв множество, которое надо обрабатывать особым образом. Соответствие задается в программе с помощью двух строк, содержащих кодируемые буквы (rusalf) и  значения кодов (latalf). Построение перекодировочной таблицы производится процедурой InitTab. После этого обработка файла  осуществляется в соответствии с построенной таблицей InitTab.
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>рограмму, решающую задачу, можно описать следующим образом:

<PRE>
program pcodfile;
  var Tabcod: array [char] of char;  f, g : text;
{Процедура InitTab формирует таблицу TabCode, в которой каждой }
{ букве русского алфавита сопоставляется одна буква латинского }
 procedure InitTab;
   var rusalf, latalf : string; i: byte; c: char;
 begin
     rusalf:='абвгдезийклмнопрстуфхйыэ';
     latalf:='abvgdezijklmnoprstufhcye';
     for c := chr(0) to chr(255) do  Tabcod[c] := c;
     for i :=1 to length(latalf) do    Tabcod[rusalf[i]] := latalf[i]
 end ; 
 procedure CodeFile(var f,g : text);
   var lr: set of char; c: char;
 begin lr:= ['ж','ч','ш','щ','ь','ъ','ю','я']; {множество особых символов }
     while not eof(f) do
          begin  while not eoln(f) do
                  begin read(f,c);
                           if c in lr
                           then case c of
                                     'ж': write(g,'sz');
                                     'ч': write(g,'ch');
                                     'ш': write(g,'sh');
                                     'щ': write(g,'sch');
                                     'ь','ъ':;
                                     'ю': write(g,'ju');
                                     'я': write(g,'ja');
                                   end
                              else write (g, Tabcod[c])
                  end;
                readln(f);  writeln(g)
          end
 end; 
  begin InitTab; Assign(f, 'fcod.pas');  Assign(g, 'gcod.pas');
            Reset(f); Rewrite(g);
            writeln ('Начали обработку файлов');
            CodeFile(f,g);
            writeln ('Кончили обработку файлов');
            Close (f);  Close (g)
  end.
</PRE>

</BLOCKQUOTE>
<P>&nbsp;
</TD>

<TD WIDTH="3%">&nbsp;</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Понятие системы,  ее структура и функция. Виды систем. &nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="3%">&nbsp;</TD>

<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>од системой  понимают совокупность взаимосвязанных и взаимодействующих объектов, подчиненных определенной единой цели.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Э</STRONG>то понятие основывается на понятиях множество и отношение, но гораздо сложнее последних. Если мы рассмотрим набор деталей, из которых можно собрать компьютер, то пока они лежат на столе отдельно друг от друга, их можно рассматривать как конечное множество деталей. Если мы будем сравнивать эти детали между собой по какому-то признаку, например, по весу или стоимости, то это уже можно рассматривать как определенное отношение на заданной предметной области. Если же из этих деталей собрать действующий компьютер, то это уже будет система. Каждая деталь, взаимодействуя с другими, внесTт свой вклад в работу системы. Система сама может являться частью другой более сложной системы. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>Н</STRONG>апример, уже рассмотренный нами компьютер будет входить как часть в систему, представляющую собой рабочее место программиста. Кроме него, в рабочее место могут входить, например, принтер, модем, графопостроитель, звуковая карта с колонками и другие системы.
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>истема считается описанной, если определены  структура системы и функция системы.
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>труктура и функционирование системы определяются поставленными перед ней целями. Целью для компьютера является автоматизация выполнения алгоритмов при помощи программ, а для рабочего места программиста -  например, возможность  произвести распечатку и пересылку результатов, полученных при  программировании, или при наборе текста в некотором редакторе, или при работе с какой-то базой данных.
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>труктура системы - это множество элементов, из которых состоит система, и взаимосвязи ( отношения)  между ними. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>С</STRONG>труктура позволяет в наглядной форме показать, из каких элементов состоит система и как эти элементы связаны друг с другом. Для представления структуры системы используют различные схемы, подобно тому, как для представления структуры программы используют блок-схемы.  Для описания систем на строгом математическом языке используется понятие графа. Основателем теории графов является Эйлер (1707 - 1782). Сейчас теория графов используется практически во всех областях науки и позволяет наглядно, ясно и вместе с тем строго описывать многие абстрактные структуры.
<P>&nbsp;&nbsp;&nbsp;<EM>Определение:</EM> графом G  называется  пара множеств  (V, E), где  V - непустое конечное множество элементов, называемых вершинами графа, а E - конечное множество пар (упорядоченных или неупорядоченных) элементов из множества V, называемых ребрами или дугами графа.
<P>&nbsp;&nbsp;&nbsp;<STRONG>В</STRONG> терминах теории графов элементы системы представляют собой вершины графа, а связи между ними - дуги. Для наглядного изображения системы посредством графа нужно точками на плоскости изобразить еT элементы, а линиями, связывающими между собой некоторые из этих точек - связи между ними. При этом расположение точек на плоскости значения не имеет. Дуги также могут быть отрезками или частями каких-то кривых, главное, чтобы они однозначно и правильно отражали, какие элементы с какими взаимодействуют.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Ф</STRONG>ункция системы представляет собой  описание всех допустимых процессов, которые могут иметь место в данной системе. Функции описывают в математической форме в виде уравнений, систем уравнений или неравенств. Иногда такое описание из-за сложности процессов невозможно в полном объTме. В этом случае некоторыми деталями информации (частью параметров, задающих систему) приходится пренебрегать. Необходимо следить, чтобы отброшенный параметр не был  существенным с точки зрения целей, ради которых система строится.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Л</STRONG>юбая система обладает важным свойством: целое, образованное из множества взаимосвязанных и взаимодействующих элементов, обладает теми качествами, которые не присущи отдельным частям этого целого. Поэтому систему нельзя рассматривать как простую сумму составляющих еT элементов. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>В</STRONG> каждый момент времени система находится в каком-то состоянии, называемом текущим. Текущее состояние системы определяется набором значений всех составляющих еT параметров.  Система называется детерминированной, если в любой момент времени можно однозначно определить еT состояние в следующий момент времени. Можно представить себе такие системы, в которых независимо от того, насколько полно определены состояния и насколько точно заданы значения параметров, невозможно точно определить последующие состояния. Такие системы называются недетерминированными.
<P>&nbsp;&nbsp;&nbsp;<STRONG>П</STRONG>о способу взаимодействия между собой отдельных частей (компонент) системы делятся на  несколько типов.
<P>&nbsp;&nbsp;&nbsp;<STRONG>Е</STRONG>сли компоненты системы могут работать друг за другом строго поочередно, то говорят о последовательной системе. Если активность компонент может иметь место одновременно, то говорят о параллельно работающей системе. Если такие системы построены из отдельных, удаленных друг от друга в пространстве компонент, то говорят о распределенных системах. 
<P>&nbsp;&nbsp;&nbsp;<STRONG>А</STRONG>рхитектура ЭВМ может быть описана как распределенная система. Другими примерами систем могут быть крупные производственные, транспортные и информационные системы, сложные электронные устройства, нервная система, солнечная система, отопительная система.
<P>&nbsp;&nbsp;&nbsp;<STRONG>А</STRONG>втоматизированные системы представляют собой совокупность управляемого объекта и автоматических управляющих устройств, где часть функций управления выполняет человек (оператор). В ней автоматические устройства осуществляют сбор информации с объекта управления, ее передачу, преобразование и обработку, формирование управляющих команд и их выполнение на управляемом объекте, то есть те функции, которые легче всего поддаются формализации.  Человек-оператор определяет цели управления и корректирует систему при изменении условий. 

</BLOCKQUOTE>
<P>&nbsp;
</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER"><FONT SIZE="+1" COLOR="White"><STRONG>&nbsp;Литература.&nbsp;</STRONG></FONT></TD>
</TR>

<TR>
<TD WIDTH="97%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;
<OL>
<LI> Ю.А.Шиханович. Введение в современную математику. М.: Наука, 1965.
<LI> Д.Кук, Д.Бейз. Компьютерная математика. М.: Наука, 1990.
<LI> Ян Стюарт. Концепции современной математики. Минск: Вышейшая школа, 1980.
<LI> Дж.Кемени, Дж.Снелл, Дж.Томпсон. Введение в конечную математику, Иностранная литература, 1963.
<LI> М.В.Дмитриева, А.А.Кубенский. Элементы современного программирования, Изд-во Санкт-Петербургского Университета,1991.
</OL>

</BLOCKQUOTE>
<P>&nbsp;
</TD>

<TD WIDTH="3%">&nbsp;</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2" ALIGN="CENTER">&nbsp;</TD>
</TR>

<TR>
<TD WIDTH="3%">&nbsp;</TD>

<TD WIDTH="97%" BGCOLOR="#EFEFEF">&nbsp;</TD>
</TR>
</TABLE>

<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" ALIGN="CENTER" VALIGN="MIDDLE" NOWRAP BGCOLOR="#82B496">
<TR>
<TD COLSPAN="2">&nbsp;</TD>
</TR>

<TR>
<TD WIDTH="70%" BGCOLOR="#EFEFEF">
<BLOCKQUOTE>
<P>&nbsp;<BR>
<STRONG>Дмитриева Марина Валерьевна</STRONG>
<P><EM>Доцент кафедры информатики<BR>
<A HREF="http://gamma.niimm.spb.ru">Санкт-Петербургского Государственного Университета</A> .</EM>

<P><STRONG>Павлова Марианна Владимировна</STRONG>
<P><EM>Cтарший преподаватель кафедры математики <A HREF="http://wg.pu.ru">СПбГУ</A> ,<BR>
преподаватель школы-лицея N 419. </EM>

</BLOCKQUOTE>
<P>&nbsp;
</TD>

<TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>&nbsp;НАШИ&nbsp;АВТОРЫ&nbsp;</EM></FONT></TD>
</TR>
<TR>
<TD COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1">
<HR SIZE="1" NOSHADE>
[ <A HREF="index.html">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE>
</FONT>
</TD>
</TR>
</TABLE>

</BODY>
</HTML>
