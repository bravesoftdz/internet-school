<HTML>
<HEAD>
<TITLE> Журнал ЦПО. Дистанционное обучение. </TITLE>
</HEAD>
<BODY BGCOLOR="#EFEFEF" TEXT="Black" LINK="Teal" VLINK="Gray" ALINK="#B3CFC4">
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
<TR>
<TD  width=3%  ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
<TD  width=88% ALIGN="CENTER" BGCOLOR="Gray">
<FONT COLOR="White">
<EM>Компьютерные</EM><BR>
<FONT SIZE="+1"><STRONG>ИНСТРУМЕНТЫ</STRONG></FONT><BR>
<EM>в образовании</EM>
</FONT></TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
</TR><TR><TD BGCOLOR="Black">&nbsp;</TD>
</TR><TR><TD COLSPAN="5" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1">
<HR SIZE="1" NOSHADE>
[ <A HREF="index.htm">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE>
</FONT>
</TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" ALIGN="CENTER" VALIGN="MIDDLE" NOWRAP BGCOLOR="#82B496">
<TR><TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>  
Школа современного прогаммирования.

</EM></FONT></TD><TD WIDTH="70%" BGCOLOR="#EFEFEF"><P ALIGN="RIGHT"><FONT SIZE="-1"><EM>

Черкасова П. Г.

</EM></FONT></P><H3 ALIGN="CENTER">

Кружки и олимпиады по программированию.
   
</H3><p>&nbsp;</TD></TR></TABLE>






<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
С незапамятных времен (с 1986 г) в городе проводятся олимпиады по программированию. Они имеют одну особенность — в них не существует возрастного деления. То есть в общем зачете соревнуются школьники всех возрастов. На первый взгляд, конечно, несправедливо, но это только на первый взгляд.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Дело в том, что в разных школах программирование преподают по разному. Где-то начинают учить общению с компьютером с пятого класса, где-то с первого, а где-то с девятого. Информатике выделено различное число часов на усмотрение администрации школы (это зависит в первую очередь от возможности обеспечить учеников компьютерами). При этом кого-то учат программировать, а кого-то просто знакомят с операционной системой. Используются различные языки программирования — Logo, Basic, C++, Pascal.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Поэтому сложно говорить о каком-то возрастном делении. Каждому школьнику предоставляется шанс проявить себя в период своего обучения. Это не значит, что пятикласснику на олимпиаде делать нечего. Если ученик пришел на олимпиаду, решил или попытался решить задачи и услышал их разбор, то на следующий год у него будет на порядок больше опыта и, следовательно, шансов пройти в следующий тур.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Существует масса кружков по математике, где учат решать математические олимпиадные задачи. И существует гораздо меньше подобных кружков по программированию.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Я несколько лет вела такой кружок в школе №470 и могу поделиться некоторым опытом.<br>

</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Первый вопрос, который возникает — это с какими классами можно заниматься. Если дети еще не достаточно владеют языком программирования, это не значит, что организовывать такой кружок еще рано. В этом случае можно давать некоторые разделы математики, которые в программу не входят, или входят очень мало, но которые необходимы при решении олимпиадных задач по программированию. Например, очень желательно, чтобы ученики умели свободно обращаться с различными системами счисления и владели комбинаторикой. Их необходимо познакомить с графами, а также вспомнить, что такое делимость и сравнимость по модулю (при этом можно на пальцах объяснить, что такое алгебра вычетов) и т. д. <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Разумеется, для участия в олимпиадах все эти вещи знать не обязательно, все это можно понимать  интуитивно и каждый раз изобретать заново. Но человек будет чувствовать себя гораздо увереннее, если он не будет плавать в этих вопросах, и сможет в любой момент использовать вышеуказанные инструменты.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Если ученики в достаточной степени владеют языком Pascal, C++ или хотя бы Basic, то с ними можно заниматься непосредственно олимпиадными задачами, по ходу дела поднимая вышеуказанные вопросы.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Для проведения занятий кружка компьютерный класс вовсе не нужен. Задача считается решенной, если предложен верный алгоритм. <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Если кружок дисциплинированный, то задачки даются на дом и дома дети над ними размышляют. Но у меня никогда не было дисциплинированного кружка, поэтому я давала время для размышления на занятии. После этого выслушиваются различные варианты решений, подвергаются умеренной критике и в процессе дискуссии появляется одно или несколько верных решений. Важно, чтобы ученики поняли, почему то или иное предложенное решение не является верным. Желательно дать возможность откорректировать решение экспромтом.<br>


</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Олимпиады бывают теоретические и практические. <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
На теоретической олимпиаде требуется изложить алгоритм решения и текст программы на каком-нибудь языке программирования (с подробными комментариями). Если алгоритм неверен или отсутствует, то задача автоматически не засчитывается даже при верном тексте программы. При верном же алгоритме допускаются мелкие ошибки и недочеты в программном коде. Поэтому важно научить детей правильно излагать алгоритм решения. Практика показала, что этому следует уделять много внимания, так как обычно ученики очень любят "жевать и комкать" алгоритмы.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
На практической олимпиаде от вас требуется только написать программу. При проверке текст программы никто не читает. Ее проверяют при помощи заранее подготовленных тестов. Вашей программе предлагается несколько вариантов исходных данных. Если она выдала верные ответы, то задача засчитывается. При этом вам может просто повезти и при неверном алгоритме ваша программа выдаст правильный результат.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Поэтому, если у школы есть возможность предоставить машинное время, то следует предлагать ученикам решить некоторые задачи на компьютере. Для этого можно использовать уже разобранные на теоретическом занятии задачи, так как все равно без готового алгоритма что-либо программировать не имеет смысла.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Если человек знает язык программирования, то сложно научить его чему-либо еще. Мастерство приходит с опытом, поэтому чем больше дети программируют, тем лучше.<br>
<br>

</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Когда ученик показывает вам программу, следует посмотреть ее текст независимо от того, работает она или нет.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Во-первых, программа должна быть "читабельной". Имеется в виду не наличие комментариев, которые, безусловно, должны присутствовать (маслом кашу не испортишь). Имеется в виду удобная структурированность и правильное разбиение алгоритма на процедуры и функции. Если вы знаете условие задачи и алгоритм решения, вы должны без проблем прочитать предъявленную программу, даже если в ней нет комментариев.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Школьники в большинстве своем себя не любят, поэтому при программировании стараются делать как можно больше ненужных действий и возможно сильнее запутать решение. Если после такого программирования школьнику удается отладить свою программу, то такому человеку следует поставить памятник.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Каждый программист знает, что не бывает программ, которые работают сразу после написания. Всегда что-нибудь да не так. Искусство программирования состоит в том, чтобы найти — что же не так, и исправить. И чем проще и понятнее написана программа, чем удобнее она разбита на процедуры и функции, тем легче это сделать.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;
Чтобы решать олимпиадные задачи по программированию, важно иметь представление о том, что такое время выполнения программы. Ведь в конечном итоге любую задачу можно решить перебором. Но на олимпиадах такое решение, как правило, не засчитывается. Переборные алгоритмы работают слишком долго.<br>


</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>
Пример:
&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Требуется перетасовать колоду, содержащую N карт.<br>
<br>
Решение № 1:<br> заводим массив целых чисел А длиной N.  Будем складывать в него карты на случайные места. Сначала этот массив заполнен нулями. Условимся, что карты пронумерованы от 1 до N.<br>
<br>
Возьмем карту №1 и выберем для нее место случайным образом в диапазоне от 1 до N (в языке Pascal это делается с помощью вызова функции random(k), которая возвращает случайное число от 0 до k). Предположим, нам выпало место №6. На выбранное место положим карту, то есть присвоим шестой ячейке массива значение 1 (номер карты). <br>
<br>
Теперь нужно выбрать место для карты с №2. После размещения первой карты у нас осталось N-1 пустое место. Перенумеруем их от 0 до N-1 и выберем одно из них случайным образом (пусть нам выпала восьмерка). Теперь на это место нужно поместить карту №2. Но для этого нужно найти пустое место с таким номером, ведь после размещения первой карты номера пустых мест не совпадают с номерами ячеек массива:<br>
<pre>
    Номера пустых мест
1 2 3 4 5   6 7	  8 9		
0 0 0 0 0 1 0 0 0 0 ...	
1 2 3 4 5 6 7 8 9 10		
     Номера ячеек<br>
</pre>
Поэтому придется пробежаться вдоль массива и отсчитать нужное место:
<pre>
   Номера пустых мест
1 2 3 4 5   6 7   8 9	
0 0 0 0 0 1 0 0 2 0 ...	
1 2 3 4 5 6 7 8 9 10		
    Номера ячеек
</pre>

В итоге для каждой из N  карт нам нужно пробежаться вдоль массива длиной N. Значит время работы программы будет порядка N2 шагов.<br>
Код на языке Pascal выглядит следующим образом:<br>


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
<pre>
program Pack1;

const MaxN =10000;   {максимально возможная длина колоды}
var A: array [1..MaxN] of integer;
    N: 1..MaxN;
  
function FindPlace(k: integer): integer; 
                    {находит свободное место с номером k}
var i, m: integer;
begin
  m:=0;         {l – число уже пройденных свободных мест}
  for i:= 1 to N do
    begin
      if A[i] = 0 then inc(m);{при обнаружении свободного
                               места увеличиваем m}
      if m = k then break;    {как только нашли нужное,
                               выходим из цикла}  
    end;

  FindPlace:= i; {возвращаем номер найденного места}
end; {конец описания функции FindPlace}

var i:integer;

begin {тело программы}
  writeln('Введите количество карт в колоде');
  readln(N);          
  for i:= 1 to N do A[i]:= 0; {заполняем массив нулями}
  for i:= 1 to N do A[ FindPlace( random(i-1)+1 ) ]:= i;
          {кладем каждую карту на случайно выбранное
           пустое место}
  writrln('Перетасованная колода:') {вывод результата}
  for i:= 1 to N do write(A[i]);
end.

</pre>

</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Решение № 2:<br> заводим массив целых чисел А длиной N (пусть N = 10).  Расположим в нем карты по порядку. Теперь вытащим случайным образом  карту (предположим, у нее будет №3) и отложим в конец колоды, то есть в последнюю ячейку массива. А карту из последней ячейки (чтобы не пропала) положим на освободившееся место:<br>

<pre>
1 2 10 4 5 6 7 8 9 3	
1 2 3  4 5 6 7 8 9 10	
   Номера ячеек
</pre>

Теперь перед нами стоит задача перетасовать колоду длиной N-1. Мы проделываем то же самое: выбираем любую карту (например, пятую) и меняем ее местами с последней (то есть с N-1-ой):

<pre>
1 2 10 4 9 6 7 8 5 3	
1 2 3  4 5 6 7 8 9 10	
   Номера ячеек	
</pre>

Теперь нам осталось перетасовать N-2 карты. <br>
И так далее. За каждый шаг мы уменьшаем колоду на 1 карту. Следовательно, программа выполнит N шагов. <br>
Код программы выглядит следующим образом:<br>


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
<pre>program Pack2;

const MaxN =10000;   {максимально возможная длина колоды}
var A: array [1..MaxN] of integer;
    N: 1..MaxN;
  
procedure DrawCard(k: integer); 
             {вытаскивает случайную карту из колоды
              длиной N меняет ее местами с последней}
var Help: integer;  {вспомогательная переменная}
    m: integer;     {номер случайной ячейки}
begin
  m:= random(k-1)+1; {вычисляем номер случайной ячейки}
  Help:= A[m]; {меняем местами}
  A[m]:= A[k]; {выбранную карту}
  A[k]:= Help; {и последнюю}
end; {конец описания функции DrawCard}

var i:integer;

begin {тело программы}
  writeln('Введите количество карт в колоде');
  readln(N);          
  for i:= 1 to N do A[i]:= i; {выстраиваем карты по
                               порядку}
  for i:= N downto 1 do DrawCard(i);
      {случайным образом вытаскиваем из колоды N карт}  
  writrln('Перетасованная колода:') {вывод результата}
  for i:= 1 to N do write(A[i]);
end.
</pre>

</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Понятно, что второе решение более оптимально, так как оно работает за меньшее число шагов. 
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
При подсчете времени работы программы следует смотреть только порядок. Как правило, невелика разница — работает программа за N шагов или за 3*N шагов. Но программа, выполняющая 1000*N шагов, работает значительно оптимальнее, чем программа, выполняющая 1/1000 *N2 шагов. 
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Время работы алгоритма играет большую роль в оценивании работ на теоретических турах олимпиад по программированию. 
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
На практических же турах среди тестов, проверяющих верность вашего решения, существует специальный тест для проверки быстродействия алгоритма. Если ваша программа работает недостаточно быстро, она этот тест просто не пройдет.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
На практических турах в условии задачи указывается максимальное время работы вашей программы. Как правило, оно берется "с потолка" и очень приблизительно (от 1 секунды до 1 минуты). На самом деле программа должна работать "мгновенно". Если приходится ждать, значит программа тест не прошла.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Есть еще один важный фактор в разработке алгоритмов — это ограниченность машинной памяти. Вы должны следить за тем, чтобы данные, которые вы храните, помещались в памяти компьютера. Так как все задачи предлагаются для решения в операционной системе DOS, то объем данных не должен превышать 64K.


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>
Пример:
</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
вводится длинное целое число A справа налево (т.е. сначала младшие разряды, а затем старшие) до 1 000 000 000 знаков. В конце стоит точка. Выяснить, делится ли A на 7.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Решение:<br> если бы число не было таким большим, мы бы просто взяли его и поделили (как говаривал товарищ Шариков). И посмотрели бы — делится или нет. Вся загвоздка в том, что мы не можем хранить его в памяти ни как число, ни как строку цифр, ни как массив цифр — не поместится.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Рассмотрим десятичное представление числа:<br>
<br>
abcd = a*1000 + b*100 + c*10 + d*1
<br>
Попробуем выяснить остаток этого числа на 7. Как известно, при сложении, вычитании и умножении мы можем заменять числа на их остатки от деления 7 (впрочем, как и на любое другое число). После такой замены остаток от деления результата на 7 не изменится.<br>
<br>
a*1000 + b*100 + c*10 + d*1 є a*6 + b*2 + c*3 + d*1 (mod 7)<br>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Следовательно, если мы подставим вместо степени десятки ее остаток от деления на 7, то вычислив значение такого выражения для нашего числа, мы узнаем его остаток от деления на 7.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Остается вычислить остатки всех нужных степеней десяток. Здесь мы опять не сможем просто взять и поделить, потому что миллионная степень десятки у нас никуда не поместится. Зато, зная предыдущую степень, мы можем вычислить следующую. Предположим, k-тая степень десятки имеет остаток 3 от деления на 7. Тогда k+1–ая степень будет иметь такой же остаток, как у числа 30, то есть 2. Соответственно, следующая будет иметь остаток, как у числа 20, то есть 6. И так далее… Скажу по секрету, что остатки степеней десяток от деления на семь зацикливаются:


<pre>
                Число
				
  0   1   2   3   4   5   6   7   8   9
10  10  10  10  10  10  10  10  10  10	

1   3   2   6   4   5   1   3   2   6	

          Остаток от деления на м 7
</pre>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Алгоритм: считаем остаток r от деления A на 7. Сначала он равен 0. Двигаемся по числу A справа налево. Для каждой цифры вычисляем остаток соответствующей степени десятки от деления на 7. Умножаем ее на текущую цифру числа и прибавляем к r. Затем вместо r берем его остаток от деления на 7 (чтобы не таскать за собой больших чисел) и переходим к следующей цифре.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Быстродействие алгоритма будет равняться N, где N — это количество знаков в числе A. Иначе говоря программа работает за линейное время.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Код на языке Pascal:


</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
<pre>program Divisibility;

var r: integer; {остаток от деления числа A на семь}
    p: integer; {остаток от деления текущей
                 степени десятки на семь}
    ch: char;   {очередная цифра в виде символа}
    n : 0..9;   {очередная цифра в виде числа}
   
begin {тело программы}
  r:=0;                      {сначала остаток равен нулю}
  p:=1;                      {остаток от деления 100 на 7}
  writeln('Введите число');
  read(ch);                 {читаем первую справа цифру}
  repeat
    n:= ord(ch) – ord(0)    {преобразуем символ в число}
    r:= (r + p*n) mod 7;   {прибавляем к остатку r цифру,
                   умноженную на остаток степени десятки}
    p:=p*10 mod 7;         {вычисляем остаток следующей 
                                         степени десятки}
    read(ch);              {считываем следующую цифру}
  until ch <> '.';

  writeln;
  if r = 0 then writeln('Число делится на 7')
           else writeln('Число не делится на 7');
end.</pre>


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Откуда берутся задачи? Во-первых, просто берется некая жизненная ситуация и придумывается ее модель. Вот несколько задач такого плана: 
<br>&nbsp;&nbsp;&nbsp;&nbsp;

<ol><li>Имеется некоторое количество (от 1 до 100) монет заданного достоинства. Требуется набрать определенную сумму или определить, что это невозможно. 
<li>Требуется сосчитать количество счастливых билетиков с номерами из 2*n (n &lt 10) цифр.
<li>Выиграть в крестики-нолики на таком поле:
<li>Игра в крестики-нолики на бесконечном поле остановлена после N (1&ltN&lt1000) ходов крестиков и ответных ходов ноликов. Определить, могут ли крестики выиграть следующим ходом, поставив пятый крестик по диагонали, вертикали или горизонтали.
<li>В картинной галерее работают сторожа. Для каждого сторожа известно время прихода на работу и время ухода. Определить, всегда ли галерея охраняется и, если да, то  можно ли уволить кого-нибудь из сторожей так, чтобы сторожей осталось как можно меньше, но при этом галерея бы все время охранялась.
<li>Разбить абзац на строчки длины N, при этом добавив недостающие пробелы.</ol>

И так далее. 


</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!-- -- -->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Еще один способ придумывать задачи: взять известный классический алгоритм и придумать задачу на его использование, при этом вставив некоторую изюминку:
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Дана карта островов: на клетчатой плоскости N клеток помечены единицами, остальные — нулями. Две клетки являются соседними, если они имеют общую границу — единичный отрезок координатной сетки. Остров — это набор соседних единичек. Клетки острова, имеющие менее четырех соседей, являются граничными. Найти остров с самой длинной границей и вывести ее  длину.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Это задача на применение классического алгоритма поиска компонент связности в графе. Изюминка состоит в том, чтобы найти длину границы острова.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
При придумывании задач можно использовать огромные запасы математических олимпиад. Обобщение математической задачи дает задачу по информатике.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Вот, например, математическая задача: в квадрате 3х3 можно перекрашивать строки и столбцы. Перекраска означает замену всех черных клеток на белые и наоборот.  Требуется перекрасить в белый цвет белый квадрат с черной клеткой в углу или доказать, что это невозможно.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Из нее получается замечательная задача по программированию: вводится квадрат NxN из белых и черных клеток. Требуется перекрасить его в белый цвет, (то есть вывести последовательность строк и столбцов, которые следует перекрасить) либо сообщить, что это невозможно.
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Еще один пример: всем известна задача о нахождении количества нулей в конце числа 100!. Если ее обобщить чуть-чуть, то получим задачу о нахождении количества нулей в конце числа N!. А если обобщить побольше, то получим задачу, требующую определить, делится ли число N! на K.
<br>&nbsp;&nbsp;&nbsp;&nbsp;


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>
















<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2">&nbsp;</TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD WIDTH="70%" BGCOLOR="#EFEFEF">
&nbsp;<p><BLOCKQUOTE><STRONG>
Черкасова Полина Генадьевна, <i>в 1994 году окончила физико-математическую школу №470, в настоящие время - студентка IV курса СПбИТМО.</i>


</STRONG></BLOCKQUOTE><P>&nbsp;</TD>
<TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>&nbsp;НАШИ&nbsp;АВТОРЫ&nbsp;</EM></FONT></TD></TR>
<TR><TD COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1"><HR SIZE="1" NOSHADE>
[ <A HREF="index.htm">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE></FONT></TD></TR></TABLE>


</BODY>
</HTML>
