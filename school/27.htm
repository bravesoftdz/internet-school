<HTML>
<HEAD>
<TITLE> Журнал ЦПО. Дистанционное обучение. </TITLE>
</HEAD>
<BODY BGCOLOR="#EFEFEF" TEXT="Black" LINK="Teal" VLINK="Gray" ALINK="#B3CFC4">
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
<TR>
<TD  width=3%  ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
<TD  width=88% ALIGN="CENTER" BGCOLOR="Gray">
<FONT COLOR="White">
<EM>Компьютерные</EM><BR>
<FONT SIZE="+1"><STRONG>ИНСТРУМЕНТЫ</STRONG></FONT><BR>
<EM>в образовании</EM>
</FONT></TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="Black">&nbsp;</TD>
<TD  width=3% ROWSPAN="2" BGCOLOR="#82B496">&nbsp;</TD>
</TR><TR><TD BGCOLOR="Black">&nbsp;</TD>
</TR><TR><TD COLSPAN="5" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1">
<HR SIZE="1" NOSHADE>
[ <A HREF="index.htm">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE>
</FONT>
</TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" ALIGN="CENTER" VALIGN="MIDDLE" NOWRAP BGCOLOR="#82B496">
<TR><TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>  
Школа современного программирования

</EM></FONT></TD><TD WIDTH="70%" BGCOLOR="#EFEFEF"><P ALIGN="RIGHT"><FONT SIZE="-1"><EM>
Соловьев Игорь Павлович

</EM></FONT></P><H3 ALIGN="CENTER">
<center><b>Изучение логического программирования<br></b>
на примере задач искусственного интеллекта</center>

   
</H3><p>&nbsp;</TD></TR></TABLE>







<!?- ?- ?->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Задачи искусственного интеллекта (ИИ) - естественная и многообещающая область применения компьютеров и науки о них. Уже в начале 50-х годов, почти сразу после появления первых компьютеров, многие группы исследователей разных стран пытались расширить традиционную область применения компьютеров (сложные математические и экономические расчеты) такими задачами, которые обычно оставляли живому интеллекту. Сюда можно отнести распознавание образов (текстовых, графических, объемных), причем как  восприятие образов, так и их интерпретацию, решение  математических задач и автоматическое доказательство теорем, всевозможные игры (в том числе и азартные), понимание естественного языка, медицинский диагноз, составление расписаний и многое другое.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
У перечисленных областей исследования имеется ряд характерных черт. Прежде всего, это символьная форма представления знаний о предметной области. Символы и цепочки символов используются для представления объектов самой различной природы - текстовой, графической, числовой. Еще одна важная особенность задач ИИ - отсутствие (незнание) простого и эффективного алгоритма решения. Обычно в таких задачах возникает проблема выбора направления решения из многих вариантов в условиях неопределенности. Говорят, что задачам ИИ присущ недетерминизм.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Обратимся к тому, какие средства формализации задач ИИ и поиска их решения предлагает информатика.


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>
Немного истории.
</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Несколько первых поколений компьютеров развивались в русле так называемой архитектуры фон Неймана. Конструкция таких машин предполагает наличие центрального процессора с локальной памятью процессора, обычно называемой регистровой, и достаточно большой однородной памяти (массива ячеек), называемой оперативной или основной, в которой хранится последовательность исполняемых инструкций и данных (программа). В целом (с небольшими вариациями) работа машины подчиняется следующей циклической схеме. Процессор извлекает из основной памяти очередную инструкцию, выбирает из основной памяти необходимые данные и загружает их в регистровую память, выполняет логическую или арифметическую инструкцию над содержимым регистров и отсылает полученные значения из регистров в основную память.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Архитектура фон Неймана фактически предопределила направление развития средств создания программного обеспечения вычислительной техники. Программы, написанные для таких машин, представляют собой упорядоченные последовательности инструкций, дополненные небольшим набором команд передачи управления. Языки программирования высокого уровня, реализующие основные принципы архитектуры фон Неймана, получили название императивных (императив - приказание, инструкция). Примерами подобных языков можно считать Фортран, Алгол 60, Алгол 68, PL/1, Паскаль, Си и многие другие.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Императивные языки оказали большое влияние на развитие науки и практики программирования. Они позволяли создавать довольно большие программные комплексы за приемлемое время. В учебной аудитории эти языки оказались достаточно хороши для изучения относительно несложных или небольших по объему реализации алгоритмов. Однако нужно ясно осознавать, что эти языки  в значительной мере аккумулируют в себе технические особенности первых поколений вычислительной техники.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Технологическая революция в области вычислительной техники и потребности практики в новых приложениях привели к нарастанию сложности программных комплексов и одновременно к появлению серьезных претензий к надежности программного обеспечения, создаваемого в рамках архитектуры фон Неймана. Ограниченность традиционной архитектуры с самого начала понимали и исследователи в области ИИ. Совместными усилиями теоретиков и практиков в конечном счете были разработаны новые подходы в области создания программных средств решения алгоритмических задач. Обратимся к одному из таких направлений - логическому программированию (ЛП).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Математическая логика использует отточенный формальный язык для представления знаний об объектах той или иной предметной области, включая явные средства выражения гипотез и суждений. Подобные качества роднят логику и искусство программирования. Понятно, что идея непосредственного применения логики в качестве средства программирования возникла практически одновременно с первыми императивными языками. Главная особенность такого подхода состоит в том, что программа (логическая) состоит из набора утверждений (аксиом), а вычисление, выполняемое под управлением такой программы, представляет собой логический вывод некоторого целевого утверждения - искомого результата. Вывод производится из аксиом программы по правилам математической логики, причем эти правила применяются автоматически, программист не должен их специально указывать.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Часто стиль программирования, проповедуемый в рамках направления ЛП, называют декларативным (в противоположность императивному), поскольку целевое ("вычисляемое") утверждение программы заранее декларирует (объявляет) искомый результат. При этом программист в своей программе не должен описывать шаг за шагом весь процесс вычислений,  доверяя поиск решения логической машине вывода.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Привлекательность применения логики в программировании состоит прежде всего в том, что в результате постепенного уточнения формулировки задачи она приобретает все более ясную форму, понятную как создателю программы, так и ее возможным читателям (потребителям). Особенно хорошо язык логики подходит для формулирования задач ИИ. Все это объясняется тем, что язык логики опирается на общие законы человеческого мышления, а не на технические особенности кодирования для вычислительной машины того или иного типа.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Даже самые активные энтузиасты императивного программирования не станут утверждать ничего подобного о своих программах, поскольку детальная проработка сложных программ, написанных на традиционных языках, зачастую настолько их усложняет (и даже запутывает), что никто, кроме авторов, понять их не может (довольно часто и авторы пасуют перед своими программами). 
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Серьезные практические результаты в области ЛП появились только в 70-е годы после того, как была подготовлена достаточная теоретическая база. Еще одним серьезным стимулом развития данного направления послужил достигнутый к этому времени значительный прогресс в развитии вычислительной техники.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Временем рождения современных реализаций идеи ЛП принято считать начало 70-х годов. К этому времени после целой череды экспериментальных языков группой Алана Колмероэ в Марселе была создана (еще неэффективная) реализация языка, заменившего последовательные вычисления машины фон Неймана на логический вывод. Интересно, что новый язык, названный Прологом (ПРОграммирование ЛОГическое), предназначался для анализа текстов, написанных на естественном языке, т.е. для решения задач, обычно относимых к области ИИ. Приблизительно в те же годы были разработаны и теоретические основы нового направления в программировании. Основными результатами в этой области мы обязаны Алану Робинсону и Роберту Ковальскому. Разумеется, в этой области работали и работают и многие другие теоретики и экспериментаторы, привести полный список которых мы не рискуем. 
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Первая реализация Пролога, выполненная кстати на Фортране, заинтересовала специалистов, но не получила широкого распространения по причине низкой эффективности (поскольку работала лишь как интерпретатор и не имела компилятора). Мешал распространению Пролога и накопившийся к этому времени у специалистов (в основном американских) общий скепсис по отношению к идее ЛП, поскольку все реализации предшественников Пролога были также неэффективны.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Настоящая революция в этой области произошла в конце 70-х, когда Дэвид Уоррен из Эдинбургского университета создал первый компилятор для языка Пролог. Этот компилятор работал настолько эффективно, что скепсис специалистов немедленно сменился всеобщим энтузиазмом. С тех пор и до настоящего времени направление ЛП успешно развивается и поддерживается как профессионалами, так и просто любителями программирования. Реализация Уоррена получила название эдинбургской и стала фактическим стандартом Пролога - наиболее распростаненного языка ЛП. Отметим, что эта реализация была выполнена на машине DEC-10. По этой причине ее иногда называют Пролог-10.


</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!?- ?- ?->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>
Пролог
&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Познакомимся теперь поближе с особенностями программирования на языке Пролог, причем за основу возьмем именно эдинбургский вариант реализации.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Синтаксис прологовских программ чрезвычайно прост и прозрачен, даже немного аскетичен. Программа состоит из упорядоченного набора предложений:
предложение_1<br>
предложение_2<br>
…<br>
предложение_n<br>
<br>причем каждое из предложений может принадлежать одному из двух типов - фактов и правил.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Правила записываются в одной из двух эквивалентных форм:
<br>заключение <font face="Symbol">&#0172</font> посылка.

<br>или
<br>заключение :- посылка.
<br>причем последняя форма используется чаще. Смысл правила: если верна посылка, то верно и заключение. Пример правила:
<br>X &lt Y :- X = 1 и Y = 2.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Прочитать такое правило можно следующим образом: "X меньше Y, если X = 1 и  Y = 2". Здесь же заметим, что имена переменных в Прологе начинаются с прописной буквы.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Факты записываются  в вид правил без посылок:
<br>&nbsp;&nbsp;&nbsp;&nbsp;
заключение.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Смысл предложения без посылки: факт - это безусловная истина. Пример факта:
 1 = 1.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Основной синтаксической единицей, кирпичиком программных конструкций прологовских программ является терм. Терм - это константа (число или символ), переменная, либо  математическое выражение вида f(t1,…,tn), где число аргументов выражения n і  0, аргументы t1, …, tn - термы, f  - некоторая символьная константа, называемая (главным) функтором  или функциональным именем данного терма. Терм последнего вида называется также функциональным. Примеры термов: число 5, символ banana, функциональные термы sort(1), father(x, y), max(sin(X), cos(Y)) и т.п. В частном случае при n = 0 функциональный терм приобретает вид f(), причем многие реализации языка разрешают писать просто f .
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Имена переменных в языке Пролог начинаются с прописной латинской буквы, а символьные константы (иногда их называют идентификаторами) начинаются со строчной латинской буквы. В записи имен переменных и символьных констант могут использоваться также десятичные цифры и знак подчеркивания, например Box_Pos_1 или monkey_has_banana.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Некоторые функциональные термы, образованные с помощью общеупотребительных в математике функциональных имен, наряду со стандартной префиксной записью допускают и эквивалентную инфиксную. Например, можно писать +(1, 2) и 1 + 2, =(a, b) и a = b и т.п. Термы именно такого типа встретились в приведенном выше примере прологовского правила.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
При наличии некоторой доли фантазии в синтакической записи терма можно усмотреть древовидную структуру. На  рис. 1 изображена структура терма max(sin(X), min(0, cos(Y))) в виде стилизованного дерева. Корень этого дерева расположен вверху, ветви ориентированы сверху вниз, листьями являются простейшие аргументы функциональных термов - константы и переменные. В узлах дерева, служащих развилками, находятся функциональные имена.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Важно подчеркнуть, что терм (структура) - это лишь "неодушевленная" последовательность символов, а не математическое выражение, которое следует вычислить. Смысл, который вкладывается в каждый терм, определяется его местом в конкретной программе.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Вернемся к структуре прологовского предложения. Заключения и посылки фактов и правил строятся из термов. С синтаксической точки зрения правила имеют следующий вид:
<br>
t0 :- t1, t2,…, tn.
<br>
где терм t0  представляет заключение правила, называемое также заголовком правила, а термы t1, t2,…, tn представляют посылку правила. Как мы видим, посылка может состоять из нескольких термов, разделенных запятыми. Факты состоят только из одного заголовка, на них можно смотреть как на правила с пустой посылкой. Все термы ti, из которых строятся факты и правила, трактуются как утверждения, запятые, разделяющие утверждения в посылках, - как логические связки и, знак :- трактуется как логическое следование (читается справа налево).


</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>

</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Приведем пример очень простой программы на языке Пролог (с подобных примеров начинаются многие учебники по этому языку).
отец(николай, евгений).
<br>отец(николай, василий).
<br>отец(евгений, александр).
<br>отец(евгений, иван).
<br>отец(василий, алексей).
<br>сын(X, Y) :- отец(Y, X).
<br>дед(X, Y) :- отец(X, Z),  отец(Z, Y).
<br>брат(X, Y) :- отец(Z, X),  отец(Z, Y).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Наша программа содержит знания о родственных связях некоторой семьи (небольшой фрагмент таких знаний). Поскольку символьные константы в языке Пролог принято начинать со строчной буквы, нам пришлось именно таким образом записывать используемые в программе собственные имена. (Кроме того, оговоримся, что реальные системы программирования часто ограничивают использование букв русского алфавита: их нельзя использовать в функциональных именах, а символьные константы в таких случаях заключаются в апострофы.)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Программа содержит пять фактов с главным функтором отец: николай - отец евгения, николай - отец василия и т.д., а также три правила. Первое  утверждает: если некто Y - отец X, то X - сын Y. Второе: если некто X - отец некоторого Z и  этот же Z - отец Y, то X - дед  Y. Третье правило интерпретируется аналогичным образом.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Считается, что группы фактов и правил с одинаковым главным функтором задают определение одного свойства или отношения (называемого также предикатом). В нашем примере пять фактов определяют отношение отец: два человека находятся в этом отношении, если в программе явно представлен соответствующий факт, либо его можно доказать на основании содержащейся в программе информации. На рис. 2 представлена графическая иллюстрация определенных в программе семейных отношений.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Предположим, что в нашем распоряжении имеется некоторая система программирования на языке Пролог и что эта система запущена и работает в диалоге с нами. Введем в систему текст нашей программы. Что можно вычислить или вывести, как принято говорить в Прологе, основываясь на такой программе- Для того чтобы это узнать, программе нужно задать вопрос или сформулировать цель. Записывается это в форме
<br>?- t1, t2,…, tn.
<br>где последовательность термов t1, t2,…, tn. имеет тот же смысл, что и в посылках правил, - это набор утверждений, одновременная истинность которых должна быть выведена из программы.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Например, на вопрос
<br>?- отец(николай, василий).
<br>программа ответит да (yes), а на вопрос
<br>?- отец(василий, александр).
<br>программа ответит нет (no). Ответы на оба вопроса программа дает после просмотра (сверху вниз) своей базы знаний и непосредственного сравнения содержания вопроса (в данном случае одного терма), с заголовками содержащихся в ней предложений (в данном конкретном случае достаточно просмотреть только факты).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Еще одна форма вопроса: 
<br>?- отец(николай, X).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Здесь вместо второго аргумента проверяемого (выводимого, доказываемого) утверждения записана переменная. Это указание программе найти значение переменной X, при котором утверждение отец(николай, X) станет истинным. Поиск решения снова осуществляется последовательным просмотром предложений и сопоставлением терма отец(николай, X) с заголовками правил. Поскольку переменная X не имеет значения, она может быть сопоставлена с любым значением второго аргумента того или иного заголовка. Первый подходящий заголовок - отец(николай, евгений), поэтому на наш вопрос программа ответит X = евгений. 
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Мы знаем, что наша задача имеет и второе решение. Если после получения первого решения ввести в систему знак ';' (стандартное соглашение эдинбургского Пролога), то поиск решения будет продолжен с той позиции в базе, в которой он был остановлен. Очередное решение - X = василий. Если после этого мы еще раз попросим систему продолжить поиск, то получим ответ no.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
До сих пор для ответов на наши вопросы использовались только факты. Для того чтобы показать, как работают правила, выясним, кто является дедом алексея:
<br>
?- дед(A, алексей).

<br>&nbsp;&nbsp;&nbsp;&nbsp;
Последовательный просмотр предложений программы приводит к тому, что терм дед(X, иван) сопоставляется с заголовком соответствующего правила, переменная A связывается с его первым аргументом - переменной X, значение иван связывается со вторым аргументом - переменной Y, а наш запрос (исходная цель) сводится к новой цели:
<br>?- отец(A, Z),  отец(Z, алексей).
<br>состоящей из двух подцелей.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Процессом вычислений по заданной нами программе руководит логическая машина вывода., т.е. машина, каждый шаг которой опирается на правила математической логики. Благодаря этим правилам доказательство заключения некоторого правила автоматически сводится к доказательству его посылки. Так что, если доказательство новых подцелей нашей программы закончится успехом, успешным будет и доказательство исходной цели.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Подцель отец(A, Z) дает решение A = николай, Z = евгений. Но доказательство подцели отец(евгений, алексей) заканчивается неуспехом!
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Мы знаем, что наша задача имеет решение, но этого не знает машина вывода. Однако эта машина имеет особый механизм поиска - бэктрекинг (механизм возврата), с помощью которого мы, в конце концов, получим решение (это не всегда возможно в реальных системах логического программирования).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
В случае, когда вычисления заходят в тупик, машина вывода прослеживает цепочку вывода в обратном направлении, пытаясь найти точку выбора - такую подцель, при доказательстве которой можно было бы найти иное решение. В нашей задаче такой подцелью является отец(A, Z). Машина пересматривает свой выбор: ранее найденное решение отменяется, поиск решения данной подцели продолжается с той точки, где он был остановлен. В результате находится новое решение A = николай, Z = василий. Тогда вторая подцель переформулируется:
<br>?-  отец(василий, алексей).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Доказательство данной подцели, а с ней и исходной цели, заканчивается успехом. Помимо успеха машина вывода возвращает и значения переменной A, содержащейся в исходном запросе: A = николай, другими словами, машина вывела, что дед алексея - николай.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Рассмотренный нами тип запроса с неопределенными значениями переменных (в Прологе говорят - несвзанных переменных) относится к числу так называемых экзистенциальных. Логическая машина вывода обладает возможностью не только проверять  истинность того или иного утверждения, но также и подбирать значения параметров, при которых утверждения становятся истинными (это называют также поиском решения проблемы).
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Наш первый пример логической программы достаточно прост и служит единственной цели - показать основные особенности языка Пролог. Хорошим примером, демонстрирующим применение идеи логического программирования для решения задач искусственого интеллекта, может служить известная задача "обезьяна и банан".
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Представим себе комнату, в которой томится голодная обезьяна. В комнате к потолку подвешен банан, причем довольно высоко. Обезьяна с пола не может дотянуться до банана. Бедное животное мечется по комнате, пытаясь найти способ добраться до плода. У окна этой комнаты находится ящик, которым обезьяна, если она достаточно сообразительна, могла бы воспользоваться как подставкой. Доберется ли обезьяна до банана-
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Мы не предлагаем ставить опыты на животных. Вместо этого представим себе поиск решения данной проблемы как игру для одного игрока, в которой определен набор допустимых состояний,  исходное состояние, заключительное состояние и правила поведения игрока (обезьяны) или правила перехода из одного состояния в другое.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Каждое состояние определяется взаимным расположением в комнате обезьяны, ящика и банана. Для определенности выделим в комнате три возможных положения, в которых могут располагаться обезьяна и ящик, - у двери, у окна и под бананом. Назовем эти положения, соответственно, at_door, at_window и under_banana. Кроме того, обезьяна может находиться на полу (on_floor) или взобраться на ящик (on_box). Предположим, что в начале игры обезьяна находится у двери. Заключительное состояние - счастливая обезьяна держит в лапах банан, стоя на ящике.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Перечислим действия, которые может предпринять обезьяна, другими словами - правила перехода нашей игры. Обезьяна может переходить (перебегать-) по полу из одного положения в другое, передвигать ящик из одного положения в другое, если ящик находится там же, где обезьяна,  забираться на ящик и спускаться с него, а также схватить банан, если она стоит на ящике прямо под бананом.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Процесс (игра) развивается в дискретном времени. Это означает, что обезьяна, находясь в некотором состоянии, выполняет одно допустимое действие (ход) и немедленно оказывается в новом состоянии, и т.д.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Опишем состояние игры синтаксическими средствами языка Пролог. Это можно сделать несколькими различными способами. Выберем следующий. Пусть текущее состояние определяется парой объектов - состоянием обезьяны и состоянием ящика. Состояние обезьяны можно представить синтаксической структурой (термом) вила monkey(HPos, VPos, Want_banana), где monkey - имя структуры, а в скобках перечислены три переменные, обозначающие, соответственно, горизонтальную позицию обезьяны (HPos), вертикальную позицию обезьяны (VPos) и наличие у обезьяны банана (Want_banana). Состояние ящика описывается его положением на полу в комнате, для чего достаточно одной переменной, например Box_Pos. Конкретные имена переменных в программе могут немного изменяться в зависимости от контекста.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Определим значения, принимаемые указанными переменными в программе, которую мы собираемся написать на языке Пролог. Для этого воспользуемся записью вида
<br>переменная <font face="Symbol">&#0206</font> множество значений
</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>





<!?- ?- ?->
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center><font size="+1" color=white>

&nbsp;</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;
Итак,
<br>HPos <font face="Symbol">&#0206</font> {at_door, at_window, under_banana},
<br>BoxPos <font face="Symbol">&#0206</font> {at_door, at_window, under_banana},
<br>VPos <font face="Symbol">&#0206</font> {on_floor, on_box},
<br>Want_banana <font face="Symbol">&#0206</font> {try_banana, has_banana}.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
На рис. 3 и 4 в виде древовидных структур изображены исходное и заключительное состояния нашей игры, соответственно.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Приведем полный текст нашей программы:
<pre>% обезьяна и банан
step(monkey(under_banana, on_box,
    try_banana), under_banana,
    grasp,    % схватить банан
    monkey(under_banana, on_box,
	has_banana), under_banana).
step(monkey(HPos, on_floor, Want_banana),
    HPos,
	climb, % залезть на ящик
    monkey(HPos, on_box, Want_banana),
	HPos).
step(monkey(HPos1, on_floor, Want_banana),
     HPos1,               %передвинуть ящик
	 move(HPos1,HPos2),  %  из HPos1 в HPos2
     monkey(HPos2, on_floor, Want_banana),
	 HPos2).
step(monkey(HPos1, on_floor, Want_banana),
     Box_Pos,           % перейти 
     go(HPos1,HPos2),   % из HPos1 в HPos2
     monkey(HPos2, on_floor, Want_banana), Box_Pos).
obtain(monkey(_, _, has_banana), _).
   % есть банан - завершить поиск 
obtain(Monkey1, Box1) :- step(Monkey1,Box1,
  % выполнить очерендной шаг
    Step,
    Monkey2,Box2),
    obtain(Monkey2,Box2).
  % продолжить поиск
goal(Monkey_Pos, Box_Pos) :- obtain(monkey
(Monkey_Pos, on_floor, try_banana),Box_Pos).</pre>
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Текст программы начинается с комментария (цепочка символов, начинающаяся со знака %). Далее следует определение отношения step, описывающее правила перехода из одного состояния в другое. Первые два, а также четвертый и пятый аргументы отношения step указывают состояния обезьяны и ящика до очередного хода и после, третий аргумент описание действия, совершаемого обезьяной. Так, первое предложение констатирует, что обезьяна может схватить (grasp) банан, если она стоит на ящике прямо под бананом. Второе предложение разрешает обезьяне залезть (climb) на ящик, она стоит на полу прямо под бананом и рядом с ней находится ящик. Третье и четвертое предложения разрешают обезьяне передвинуть ящик или перейти самой из одной позиции в другую.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Далее описывается предиката obtain ? основная движущая сила нашей игры. Первое предложение в определении  ? факт, описывающий заключительное состояние: обезьяна держит в лапах банан (has_banana). Второе предложение имеет два условия и, соответственно, порождает две подцели: сначала выполняется очередной шаг игры, затем вызывается предикат obtain (рекурсивно) с параметрами нового состояния игры, и т.д., пока не будет достигнуто заключительное состояние.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Последний предикат goal включен в программу для удобства. С его помощью можно сформировать цель  
<br>
?- goal(at_door, at_window).
<br>
-и запустить игру в начальном состоянии: обезьяна ? у двери, ящик ? у окна. Предикат goal формирует параметры для подцели obtain и передает ей управление. Получив такой запрос, наша программа ответит yes, что будет означать успешное окончание игры ? обезьяна получит свою награду.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Наша программа описывает процесс игры исключительно логическими средствами в виде отношений участников и атрибутов игры. Это описание оказалось весьма кратким и выразительным, что еще раз оправдывает закрепившееся за подобным стилем программирования название декларативый.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Декларативный стиль позволяет нам указать, что именно мы хотим узнать или вывести из программы, не уточняя, как именно будет достигнута наша цель. Конкретная последовательность шагов, решающая поставленную задачу, определяется логической машиной вывода по правила математической логики и может быть весьма нетривиальной.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Жизнь, как всегда, богаче любых схем. Получив ответ yes в задаче про обезьяну и банан, мы, тем не менее, хотим узнать немного больше: как долго искала решение логическая машина и какие конкретные шаги все же ей пришлось предпринять (например, для того чтобы не делать ошибок). Помогает получить ответы на такие вопросы встроенный отладчик, который принято включать в системы логического программирования. Запустив такой отладчик, мы может проследить всю трассу логического вывода и непосредственно увидеть точки возврата и выбора. Так, в нашей задаче мы может увидеть, как обезьяна добегает до окна, забирается на ящик, слезает с него, затем двигает ящик под банан, снова забирается и, наконец, достигает заветной цели.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
Как мы видим, путь к достижению цели может быть непрямым. Рекомендуем поэкспериментировать с предложенной программой, изменяя последовательность ее предложений.
<br>&nbsp;&nbsp;&nbsp;&nbsp;
В заключение отметим, что в настоящее время существует много реализаций языков логического программирования для различных операционных систем. Мы не беремся выделить лучшую из них, поскольку в каждой есть свои особенности. Скажем лишь, что программы, включенные в текст данной статьи, написаны и отлажены в системе Amzi! Prolog, работающей под управлением операционной системы Windows 95/98. Бесплатную 90-дневную копию этой программы можно найти в Интернете по адресу www.amzi.com.<br><br>
</BLOCKQUOTE><P>&nbsp;</TD><TD WIDTH="3%">&nbsp;</TD></TR></TABLE>



<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2" align=center>&nbsp;<font size="+1" color=white>
Литература:
</font></TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD WIDTH="3%">&nbsp;</TD>
<TD WIDTH="97%" BGCOLOR="#EFEFEF"><BLOCKQUOTE><P>&nbsp;<p>
<p>
<ol>
<li>И. Братко. программирование на языке Пролог для искусственного интеллекта. М., 1990.
<li>У. Клоксин, К. Меллиш. Программирование на языке Пролог. М., 1987.</ol>




</BLOCKQUOTE><P>&nbsp;</TD></TR></TABLE>






















<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR><TD COLSPAN="2">&nbsp;</TD></TR></TABLE>
<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="3" BGCOLOR="#82B496">
<TR>
<TD WIDTH="70%" BGCOLOR="#EFEFEF">
&nbsp;<p><BLOCKQUOTE><STRONG>
Соловьев Игорь Павлович, <i>доцент кафедры информатики мат.-мех. факультета СПбГУ.</i>


</STRONG></BLOCKQUOTE><P>&nbsp;</TD>
<TD WIDTH="30%" ALIGN="CENTER" VALIGN="MIDDLE"><FONT COLOR="White" SIZE="+2"><EM>&nbsp;НАШИ&nbsp;АВТОРЫ&nbsp;</EM></FONT></TD></TR>
<TR><TD COLSPAN="2" ALIGN="CENTER" VALIGN="MIDDLE" BGCOLOR="#82B496">
<FONT SIZE="-1"><HR SIZE="1" NOSHADE>
[ <A HREF="index.htm">начало</A> ] [ <A HREF="http://www.aec.neva.ru/center/">ЦПО</A> ] [ <A HREF="mailto:pozdnkov@aec.neva.ru">e-mail</A> ] 
<HR SIZE="1" NOSHADE></FONT></TD></TR></TABLE>


</BODY>
</HTML>
