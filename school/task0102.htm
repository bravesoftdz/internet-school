<html>
<head><title>Разбор задачи 0102 (2-ой задачи 1-ого занятия)</title></head>
<body>
<pre>

<center><b><u>Задание:</u></b></center>
Предложите алгоритм выбора пар для вычитания, обеспечивающий 
возможно меньшее число шагов в методе нахождения НОД (Наибольшего
Общего Делителя) при помощи алгоритма Евклида с вычитаниями.

<center><b><u>Текст программы:</u></b></center>
{ Разбор задачи 0102 (2-ой задачи 1-ого занятия) }
{ Задание: }
{ Предложите алгоритм выбора пар для вычитания, обеспечивающий }
{ возможно меньшее число шагов в методе нахождения НОД (Наибольшего }
{ Общего Делителя) при помощи алгоритма Евклида с вычитаниями. }
Var
  N : LongInt; { Количество чисел в наборе. Максимум - 100 чисел }
  A : Array [1..100] of LongInt; { Массив для хранения этих чисел }
  Min : LongInt; { Минимальное количество шагов }
  P : Array [1..100,1..2] of LongInt; { Текущее решение }
  PM : Array [1..100,1..2] of LongInt; { Наилучшее решение }

{ Рекурсивная процедура перебора дерева вариантов выбора пар для вычитания }
Procedure Rec( K:Word ); { K - Текущее количество шагов }
  Var Cnt,I,J:Integer;
  Begin
    If K >= Min then Exit; { Отсекаем лишние ветки перебора }
   { Подсчитываем количество ненулевых элементов }
    Cnt:=0; For I:=1 to N do If A[I]<>0 then Inc(Cnt);
   { Если очередное решение найдено, запоминаем его }
    If Cnt = 1 then
      Begin
        For I:=1 to (K-1) do { Запоминаем решение как наилучшее }
          For J:=1 to 2 do
            PM[I,J]:=P[I,J];
        Min:=K-1;
        Exit;
      End;
   { Новый шаг перебора }
    For I:=1 to N do
      For J:=1 to N do
        If ((A[I] >= A[J]) And (I<>J) And (A[J]<>0)) then
          Begin
            P[K,1]:=I; { Запоминаем уменьшаемое }
            P[K,2]:=J; { Запоминаем вычитаемое }
            A[I]:=A[I]-A[J]; { Вычитаем из уменьшаемого вычитаемое }
            Rec(K+1); { Новый шаг рекурсии }
            A[I]:=A[I]+A[J]; { Обратно добавляем вычитаемое }
          End;
  End;

{ Основная программа }
Var I:LongInt;
Begin
  Read(N); { Считываем их входного потока количество чисел в наборе }
  For I:=1 to N do Read(A[I]); { Считываем собственно числа набора }
  Min:=MaxLongInt; { Сначала минимальное количество шагов как можно больше }
  Rec(1); { Перебираем дерево вариантов и находим оптимальный }
  Writeln(Min); { Выводим количество шагов (пар для вычитания) }
  For I:=1 to (Min) do { Выводим последовательность шагов }
    Writeln(PM[I,1],' ',PM[I,2]);
End.
</pre>
</body>
</html>